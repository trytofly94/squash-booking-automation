/**
 * Health Check Manager for comprehensive system monitoring
 * Provides website availability, system health, and booking analytics
 */

import { Page } from '@playwright/test';
import { 
  HealthStatus, 
  HealthCheckResult, 
  SystemHealth, 
  WebsiteAvailabilityCheck, 
  HealthCheckConfig, 
  SystemMetrics 
} from '@/types/health.types';
import { performanceMonitor } from '@/utils/PerformanceMonitor';
import { correlationManager } from '@/utils/CorrelationManager';
import { logger } from '@/utils/logger';

class HealthCheckManager {
  private config: HealthCheckConfig;
  private lastHealthCheck: SystemHealth | null = null;
  private healthCheckHistory: HealthCheckResult[] = [];
  private systemMetrics: SystemMetrics;
  private isRunning = false;
  private intervalId: NodeJS.Timer | null = null;

  constructor() {
    this.config = {
      enabled: process.env['HEALTH_CHECK_ENABLED']?.toLowerCase() === 'true' || true,
      interval: parseInt(process.env['HEALTH_CHECK_INTERVAL'] || '300000', 10), // 5 minutes
      timeout: parseInt(process.env['HEALTH_CHECK_TIMEOUT'] || '30000', 10), // 30 seconds
      websiteUrl: process.env['WEBSITE_URL'] || 'https://www.eversports.de/sb/sportcenter-kautz?sport=squash',
      retryAttempts: parseInt(process.env['HEALTH_CHECK_RETRIES'] || '3', 10),
      alertThresholds: {
        responseTime: parseInt(process.env['ALERT_THRESHOLD_RESPONSE_TIME'] || '5000', 10),
        errorRate: parseFloat(process.env['ALERT_THRESHOLD_ERROR_RATE'] || '10'),
        memoryUsage: parseFloat(process.env['ALERT_THRESHOLD_MEMORY'] || '80')
      }
    };

    this.systemMetrics = this.initializeSystemMetrics();
    
    if (this.config.enabled) {\n      this.startPeriodicHealthChecks();\n    }\n  }\n\n  /**\n   * Start periodic health checks\n   */\n  startPeriodicHealthChecks(): void {\n    if (this.isRunning || !this.config.enabled) {\n      return;\n    }\n\n    this.isRunning = true;\n    logger.info('Starting periodic health checks', 'HealthCheckManager', {\n      interval: this.config.interval,\n      websiteUrl: this.config.websiteUrl\n    });\n\n    // Run initial health check\n    this.runFullHealthCheck().catch(error => {\n      logger.logStructuredError(error, 'system', 'HealthCheckManager', {\n        operation: 'initial_health_check'\n      });\n    });\n\n    // Schedule periodic checks\n    this.intervalId = setInterval(() => {\n      this.runFullHealthCheck().catch(error => {\n        logger.logStructuredError(error, 'system', 'HealthCheckManager', {\n          operation: 'periodic_health_check'\n        });\n      });\n    }, this.config.interval);\n  }\n\n  /**\n   * Stop periodic health checks\n   */\n  stopPeriodicHealthChecks(): void {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n      this.intervalId = null;\n    }\n    this.isRunning = false;\n    logger.info('Stopped periodic health checks', 'HealthCheckManager');\n  }\n\n  /**\n   * Run comprehensive health check\n   */\n  async runFullHealthCheck(): Promise<SystemHealth> {\n    const correlationId = correlationManager.getCurrentCorrelationId() || correlationManager.generateCorrelationId();\n    const timerId = logger.startTiming('full_health_check', 'HealthCheckManager');\n\n    try {\n      logger.info('Running full health check', 'HealthCheckManager', { correlationId });\n\n      const checks: HealthCheckResult[] = [];\n\n      // System resource check\n      checks.push(await this.checkSystemResources());\n\n      // Website availability check\n      checks.push(await this.checkWebsiteAvailability());\n\n      // Application health check\n      checks.push(await this.checkApplicationHealth());\n\n      // Performance health check\n      checks.push(await this.checkPerformanceHealth());\n\n      // Determine overall status\n      const overallStatus = this.determineOverallStatus(checks);\n      \n      // Update metrics\n      this.updateSystemMetrics();\n\n      const health: SystemHealth = {\n        status: overallStatus,\n        timestamp: Date.now(),\n        version: process.env['npm_package_version'] || '1.0.0',\n        uptime: process.uptime(),\n        checks,\n        metrics: {\n          memoryUsage: this.systemMetrics.memoryUsage.percentage,\n          responseTime: this.systemMetrics.averageResponseTime,\n          errorRate: this.systemMetrics.errorRate\n        }\n      };\n\n      this.lastHealthCheck = health;\n      this.addToHistory(checks);\n\n      logger.info('Health check completed', 'HealthCheckManager', {\n        status: overallStatus,\n        checksCount: checks.length,\n        failedChecks: checks.filter(c => c.status === HealthStatus.UNHEALTHY).length\n      });\n\n      return health;\n    } catch (error) {\n      logger.logStructuredError(error, 'system', 'HealthCheckManager', {\n        operation: 'full_health_check'\n      });\n      throw error;\n    } finally {\n      logger.endTiming(timerId);\n    }\n  }\n\n  /**\n   * Check system resources\n   */\n  async checkSystemResources(): Promise<HealthCheckResult> {\n    const startTime = Date.now();\n    \n    try {\n      const resourceInfo = performanceMonitor.getSystemResourceInfo();\n      const memoryUsagePercent = (resourceInfo.memoryUsage.heapUsed / resourceInfo.memoryUsage.heapTotal) * 100;\n      \n      const status = memoryUsagePercent > this.config.alertThresholds.memoryUsage \n        ? HealthStatus.DEGRADED \n        : HealthStatus.HEALTHY;\n\n      return {\n        name: 'system_resources',\n        status,\n        timestamp: Date.now(),\n        duration: Date.now() - startTime,\n        message: `Memory usage: ${memoryUsagePercent.toFixed(2)}%`,\n        details: {\n          memoryUsage: resourceInfo.memoryUsage,\n          uptime: resourceInfo.uptime,\n          nodeVersion: resourceInfo.nodeVersion,\n          platform: resourceInfo.platform\n        }\n      };\n    } catch (error) {\n      return {\n        name: 'system_resources',\n        status: HealthStatus.UNHEALTHY,\n        timestamp: Date.now(),\n        duration: Date.now() - startTime,\n        error: error instanceof Error ? error.message : String(error)\n      };\n    }\n  }\n\n  /**\n   * Check website availability\n   */\n  async checkWebsiteAvailability(): Promise<HealthCheckResult> {\n    const startTime = Date.now();\n    \n    try {\n      const availabilityCheck = await this.performWebsiteCheck();\n      \n      const status = availabilityCheck.status === HealthStatus.HEALTHY \n        ? HealthStatus.HEALTHY \n        : availabilityCheck.responseTime > this.config.alertThresholds.responseTime\n        ? HealthStatus.DEGRADED\n        : HealthStatus.UNHEALTHY;\n\n      return {\n        name: 'website_availability',\n        status,\n        timestamp: Date.now(),\n        duration: Date.now() - startTime,\n        message: `Response time: ${availabilityCheck.responseTime}ms`,\n        details: {\n          url: availabilityCheck.url,\n          statusCode: availabilityCheck.statusCode,\n          responseTime: availabilityCheck.responseTime\n        },\n        error: availabilityCheck.error\n      };\n    } catch (error) {\n      return {\n        name: 'website_availability',\n        status: HealthStatus.UNHEALTHY,\n        timestamp: Date.now(),\n        duration: Date.now() - startTime,\n        error: error instanceof Error ? error.message : String(error)\n      };\n    }\n  }\n\n  /**\n   * Check application health\n   */\n  async checkApplicationHealth(): Promise<HealthCheckResult> {\n    const startTime = Date.now();\n    \n    try {\n      // Check if core components are healthy\n      const correlationEnabled = correlationManager.isEnabled();\n      const performanceEnabled = performanceMonitor.isEnabled();\n      const loggerStats = logger.getStats();\n      \n      // Check if any critical errors occurred recently\n      const bookingMetrics = loggerStats.bookingMetrics;\n      const recentFailureRate = bookingMetrics.totalSteps > 0 \n        ? ((bookingMetrics.failedSteps / bookingMetrics.totalSteps) * 100)\n        : 0;\n\n      const status = recentFailureRate > this.config.alertThresholds.errorRate\n        ? HealthStatus.DEGRADED\n        : HealthStatus.HEALTHY;\n\n      return {\n        name: 'application_health',\n        status,\n        timestamp: Date.now(),\n        duration: Date.now() - startTime,\n        message: `Application components operational`,\n        details: {\n          correlationEnabled,\n          performanceEnabled,\n          totalBookingSteps: bookingMetrics.totalSteps,\n          successRate: bookingMetrics.successRate,\n          recentFailureRate\n        }\n      };\n    } catch (error) {\n      return {\n        name: 'application_health',\n        status: HealthStatus.UNHEALTHY,\n        timestamp: Date.now(),\n        duration: Date.now() - startTime,\n        error: error instanceof Error ? error.message : String(error)\n      };\n    }\n  }\n\n  /**\n   * Check performance health\n   */\n  async checkPerformanceHealth(): Promise<HealthCheckResult> {\n    const startTime = Date.now();\n    \n    try {\n      const performanceSummary = performanceMonitor.getMetricsSummary();\n      \n      const status = performanceSummary.metricsAboveErrorThreshold > 0\n        ? HealthStatus.UNHEALTHY\n        : performanceSummary.metricsAboveWarningThreshold > 0\n        ? HealthStatus.DEGRADED\n        : HealthStatus.HEALTHY;\n\n      return {\n        name: 'performance_health',\n        status,\n        timestamp: Date.now(),\n        duration: Date.now() - startTime,\n        message: `Average response time: ${performanceSummary.averageDuration.toFixed(2)}ms`,\n        details: {\n          totalMetrics: performanceSummary.totalMetrics,\n          averageDuration: performanceSummary.averageDuration,\n          metricsAboveWarning: performanceSummary.metricsAboveWarningThreshold,\n          metricsAboveError: performanceSummary.metricsAboveErrorThreshold\n        }\n      };\n    } catch (error) {\n      return {\n        name: 'performance_health',\n        status: HealthStatus.UNHEALTHY,\n        timestamp: Date.now(),\n        duration: Date.now() - startTime,\n        error: error instanceof Error ? error.message : String(error)\n      };\n    }\n  }\n\n  /**\n   * Perform website availability check using fetch\n   */\n  private async performWebsiteCheck(): Promise<WebsiteAvailabilityCheck> {\n    const startTime = Date.now();\n    \n    try {\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), this.config.timeout);\n      \n      const response = await fetch(this.config.websiteUrl, {\n        method: 'HEAD',\n        signal: controller.signal,\n        headers: {\n          'User-Agent': 'SquashBooking-HealthCheck/1.0'\n        }\n      });\n      \n      clearTimeout(timeoutId);\n      const responseTime = Date.now() - startTime;\n      \n      return {\n        url: this.config.websiteUrl,\n        status: response.ok ? HealthStatus.HEALTHY : HealthStatus.DEGRADED,\n        responseTime,\n        statusCode: response.status,\n        timestamp: Date.now()\n      };\n    } catch (error) {\n      const responseTime = Date.now() - startTime;\n      \n      return {\n        url: this.config.websiteUrl,\n        status: HealthStatus.UNHEALTHY,\n        responseTime,\n        timestamp: Date.now(),\n        error: error instanceof Error ? error.message : String(error)\n      };\n    }\n  }\n\n  /**\n   * Determine overall health status from individual checks\n   */\n  private determineOverallStatus(checks: HealthCheckResult[]): HealthStatus {\n    const unhealthyCount = checks.filter(c => c.status === HealthStatus.UNHEALTHY).length;\n    const degradedCount = checks.filter(c => c.status === HealthStatus.DEGRADED).length;\n    \n    if (unhealthyCount > 0) {\n      return HealthStatus.UNHEALTHY;\n    } else if (degradedCount > 0) {\n      return HealthStatus.DEGRADED;\n    } else {\n      return HealthStatus.HEALTHY;\n    }\n  }\n\n  /**\n   * Initialize system metrics\n   */\n  private initializeSystemMetrics(): SystemMetrics {\n    const resourceInfo = performanceMonitor.getSystemResourceInfo();\n    \n    return {\n      memoryUsage: {\n        used: resourceInfo.memoryUsage.heapUsed,\n        total: resourceInfo.memoryUsage.heapTotal,\n        percentage: (resourceInfo.memoryUsage.heapUsed / resourceInfo.memoryUsage.heapTotal) * 100\n      },\n      uptime: resourceInfo.uptime,\n      averageResponseTime: 0,\n      errorRate: 0,\n      requestCount: 0,\n      lastRequestTime: Date.now()\n    };\n  }\n\n  /**\n   * Update system metrics\n   */\n  private updateSystemMetrics(): void {\n    const resourceInfo = performanceMonitor.getSystemResourceInfo();\n    const performanceSummary = performanceMonitor.getMetricsSummary();\n    const bookingMetrics = performanceMonitor.getBookingStepsSummary();\n    \n    this.systemMetrics = {\n      memoryUsage: {\n        used: resourceInfo.memoryUsage.heapUsed,\n        total: resourceInfo.memoryUsage.heapTotal,\n        percentage: (resourceInfo.memoryUsage.heapUsed / resourceInfo.memoryUsage.heapTotal) * 100\n      },\n      uptime: resourceInfo.uptime,\n      averageResponseTime: performanceSummary.averageDuration,\n      errorRate: bookingMetrics.totalSteps > 0 ? ((bookingMetrics.failedSteps / bookingMetrics.totalSteps) * 100) : 0,\n      requestCount: performanceSummary.totalMetrics,\n      lastRequestTime: Date.now()\n    };\n  }\n\n  /**\n   * Add health check results to history\n   */\n  private addToHistory(checks: HealthCheckResult[]): void {\n    this.healthCheckHistory.push(...checks);\n    \n    // Keep only last 100 checks\n    if (this.healthCheckHistory.length > 100) {\n      this.healthCheckHistory = this.healthCheckHistory.slice(-100);\n    }\n  }\n\n  /**\n   * Get last health check result\n   */\n  getLastHealthCheck(): SystemHealth | null {\n    return this.lastHealthCheck;\n  }\n\n  /**\n   * Get health check history\n   */\n  getHealthCheckHistory(): HealthCheckResult[] {\n    return [...this.healthCheckHistory];\n  }\n\n  /**\n   * Get current configuration\n   */\n  getConfig(): HealthCheckConfig {\n    return { ...this.config };\n  }\n\n  /**\n   * Update configuration\n   */\n  updateConfig(newConfig: Partial<HealthCheckConfig>): void {\n    this.config = { ...this.config, ...newConfig };\n    \n    if (this.config.enabled && !this.isRunning) {\n      this.startPeriodicHealthChecks();\n    } else if (!this.config.enabled && this.isRunning) {\n      this.stopPeriodicHealthChecks();\n    }\n  }\n\n  /**\n   * Manual health check trigger\n   */\n  async triggerHealthCheck(): Promise<SystemHealth> {\n    logger.info('Manual health check triggered', 'HealthCheckManager');\n    return await this.runFullHealthCheck();\n  }\n\n  /**\n   * Get system status summary\n   */\n  getSystemStatus(): {\n    isHealthy: boolean;\n    status: HealthStatus;\n    lastCheckTime: number | null;\n    nextCheckTime: number | null;\n    checksRunning: boolean;\n  } {\n    return {\n      isHealthy: this.lastHealthCheck?.status === HealthStatus.HEALTHY,\n      status: this.lastHealthCheck?.status || HealthStatus.UNHEALTHY,\n      lastCheckTime: this.lastHealthCheck?.timestamp || null,\n      nextCheckTime: this.isRunning ? Date.now() + this.config.interval : null,\n      checksRunning: this.isRunning\n    };\n  }\n\n  /**\n   * Clean up resources\n   */\n  dispose(): void {\n    this.stopPeriodicHealthChecks();\n    this.healthCheckHistory = [];\n    this.lastHealthCheck = null;\n  }\n}\n\n// Export singleton instance\nexport const healthCheckManager = new HealthCheckManager();\nexport { HealthCheckManager };